use serde :: { Serialize , Deserialize } ; use xid ;
pub trait NodeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn new (id : Option < String >) -> Self ; fn to_string (& self) -> String ; fn family_name (& self) -> String ; } pub trait Node : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { type Id : NodeId ; fn id (& self) -> & Self :: Id ; fn in_edge_ids (& self) -> Vec < String > ; fn out_edge_ids (& self) -> Vec < String > ; fn family_name (& self) -> String ; fn add_in_edge_id (& mut self , edge_id : String) ; fn remove_in_edge_id (& mut self , edge_id : & str) ; fn add_out_edge_id (& mut self , edge_id : String) ; fn remove_out_edge_id (& mut self , edge_id : & str) ; }
pub trait EdgeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn to_string (& self) -> String ; fn family_name (& self) -> String ; } pub trait EdgeConnection : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { } pub trait Edge : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { type Id : EdgeId ; type Connection : EdgeConnection ; fn id (& self) -> & Self :: Id ; fn connection (& self) -> & Self :: Connection ; fn family_name (& self) -> String ; }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct SomeNodeTypeId (String) ; impl NodeId for SomeNodeTypeId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (SomeNodeType) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (SomeNodeType) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct SomeNodeType { id : SomeNodeTypeId , in_edge_ids : Vec < String > , out_edge_ids : Vec < String > , data : String , other_data : String , } impl SomeNodeType { pub fn new (id : Option < String > , data : String , other_data : String ,) -> Self { Self { id : SomeNodeTypeId (format ! (concat ! (stringify ! (SomeNodeType) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , data , other_data , } } } impl std :: str :: FromStr for SomeNodeType { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for SomeNodeType { type Id = SomeNodeTypeId ; fn id (& self) -> & SomeNodeTypeId { & self . id } fn in_edge_ids (& self) -> Vec < String > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : String) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : & str) { self . in_edge_ids . retain (| x | x != edge_id) ; } fn out_edge_ids (& self) -> Vec < String > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : String) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : & str) { self . out_edge_ids . retain (| x | x != edge_id) ; } fn family_name (& self) -> String { stringify ! (SomeNodeType) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct AnotherNodeTypeId (String) ; impl NodeId for AnotherNodeTypeId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (AnotherNodeType) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (AnotherNodeType) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct AnotherNodeType { id : AnotherNodeTypeId , in_edge_ids : Vec < String > , out_edge_ids : Vec < String > , data : String , tracked : bool , } impl AnotherNodeType { pub fn new (id : Option < String > , data : String , tracked : bool ,) -> Self { Self { id : AnotherNodeTypeId (format ! (concat ! (stringify ! (AnotherNodeType) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , data , tracked , } } } impl std :: str :: FromStr for AnotherNodeType { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for AnotherNodeType { type Id = AnotherNodeTypeId ; fn id (& self) -> & AnotherNodeTypeId { & self . id } fn in_edge_ids (& self) -> Vec < String > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : String) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : & str) { self . in_edge_ids . retain (| x | x != edge_id) ; } fn out_edge_ids (& self) -> Vec < String > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : String) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : & str) { self . out_edge_ids . retain (| x | x != edge_id) ; } fn family_name (& self) -> String { stringify ! (AnotherNodeType) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct SomeEdgeTypeId (String) ; impl EdgeId for SomeEdgeTypeId { fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (SomeEdgeType) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub enum SomeEdgeTypeConnection { FirstConnectionType (SomeNodeTypeId , AnotherNodeTypeId) } impl EdgeConnection for SomeEdgeTypeConnection { } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct SomeEdgeType { id : SomeEdgeTypeId , connection : SomeEdgeTypeConnection , weight : f64 , } impl SomeEdgeType { pub fn new (id : Option < String > , connection : SomeEdgeTypeConnection , weight : f64 ,) -> Self { Self { id : SomeEdgeTypeId (format ! (concat ! (stringify ! (SomeEdgeType) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) , connection , weight } } pub fn id (& self) -> & SomeEdgeTypeId { & self . id } } impl std :: str :: FromStr for SomeEdgeType { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Edge for SomeEdgeType { type Id = SomeEdgeTypeId ; type Connection = SomeEdgeTypeConnection ; fn id (& self) -> & SomeEdgeTypeId { & self . id } fn connection (& self) -> & Self :: Connection { & self . connection } fn family_name (& self) -> String { stringify ! (SomeEdgeType) . to_string () } }
pub fn families () -> Vec < & 'static str > { vec ! ["SomeNodeType" , "AnotherNodeType" , "SomeEdgeType"] }
