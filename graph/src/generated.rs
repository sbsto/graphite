use serde :: { Serialize , Deserialize } ; use xid ;
pub trait NodeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn new (id : Option < String >) -> Self ; fn to_string (& self) -> String ; fn family_name (& self) -> String ; } pub trait Node : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { type Id : NodeId ; fn id (& self) -> & Self :: Id ; fn in_edge_ids (& self) -> Vec < String > ; fn out_edge_ids (& self) -> Vec < String > ; fn family_name (& self) -> String ; fn add_in_edge_id (& mut self , edge_id : String) ; fn remove_in_edge_id (& mut self , edge_id : & str) ; fn add_out_edge_id (& mut self , edge_id : String) ; fn remove_out_edge_id (& mut self , edge_id : & str) ; }
pub trait EdgeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn to_string (& self) -> String ; fn family_name (& self) -> String ; } pub trait EdgeConnection : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { } pub trait Edge : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { type Id : EdgeId ; type Connection : EdgeConnection ; fn id (& self) -> & Self :: Id ; fn connection (& self) -> & Self :: Connection ; fn family_name (& self) -> String ; }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct SongId (String) ; impl NodeId for SongId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (Song) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (Song) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct Song { id : SongId , in_edge_ids : Vec < String > , out_edge_ids : Vec < String > , title : String , } impl Song { pub fn new (id : Option < String > , title : String ,) -> Self { Self { id : SongId (format ! (concat ! (stringify ! (Song) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , title , } } } impl std :: str :: FromStr for Song { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for Song { type Id = SongId ; fn id (& self) -> & SongId { & self . id } fn in_edge_ids (& self) -> Vec < String > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : String) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : & str) { self . in_edge_ids . retain (| x | x != edge_id) ; } fn out_edge_ids (& self) -> Vec < String > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : String) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : & str) { self . out_edge_ids . retain (| x | x != edge_id) ; } fn family_name (& self) -> String { stringify ! (Song) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct ArtistId (String) ; impl NodeId for ArtistId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (Artist) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (Artist) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct Artist { id : ArtistId , in_edge_ids : Vec < String > , out_edge_ids : Vec < String > , name : String , } impl Artist { pub fn new (id : Option < String > , name : String ,) -> Self { Self { id : ArtistId (format ! (concat ! (stringify ! (Artist) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , name , } } } impl std :: str :: FromStr for Artist { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for Artist { type Id = ArtistId ; fn id (& self) -> & ArtistId { & self . id } fn in_edge_ids (& self) -> Vec < String > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : String) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : & str) { self . in_edge_ids . retain (| x | x != edge_id) ; } fn out_edge_ids (& self) -> Vec < String > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : String) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : & str) { self . out_edge_ids . retain (| x | x != edge_id) ; } fn family_name (& self) -> String { stringify ! (Artist) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct AlbumId (String) ; impl NodeId for AlbumId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (Album) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (Album) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct Album { id : AlbumId , in_edge_ids : Vec < String > , out_edge_ids : Vec < String > , title : String , } impl Album { pub fn new (id : Option < String > , title : String ,) -> Self { Self { id : AlbumId (format ! (concat ! (stringify ! (Album) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , title , } } } impl std :: str :: FromStr for Album { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for Album { type Id = AlbumId ; fn id (& self) -> & AlbumId { & self . id } fn in_edge_ids (& self) -> Vec < String > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : String) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : & str) { self . in_edge_ids . retain (| x | x != edge_id) ; } fn out_edge_ids (& self) -> Vec < String > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : String) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : & str) { self . out_edge_ids . retain (| x | x != edge_id) ; } fn family_name (& self) -> String { stringify ! (Album) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct ById (String) ; impl EdgeId for ById { fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (By) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub enum ByConnection { SongIsBy (SongId , ArtistId) , AlbumIsBy (AlbumId , ArtistId) } impl EdgeConnection for ByConnection { } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct By { id : ById , connection : ByConnection , weight : f64 , } impl By { pub fn new (id : Option < String > , connection : ByConnection , weight : f64 ,) -> Self { Self { id : ById (format ! (concat ! (stringify ! (By) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) , connection , weight } } pub fn id (& self) -> & ById { & self . id } } impl std :: str :: FromStr for By { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Edge for By { type Id = ById ; type Connection = ByConnection ; fn id (& self) -> & ById { & self . id } fn connection (& self) -> & Self :: Connection { & self . connection } fn family_name (& self) -> String { stringify ! (By) . to_string () } }
pub fn families () -> Vec < & 'static str > { vec ! ["Song" , "Artist" , "Album" , "By"] }
