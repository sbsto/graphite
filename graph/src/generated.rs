use serde :: { Serialize , Deserialize } ; use xid ;
pub trait Node : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn id (& self) -> & str ; fn in_edge_ids (& self) -> Vec < String > ; fn out_edge_ids (& self) -> Vec < String > ; fn family_name (& self) -> String ; fn add_in_edge_id (& mut self , edge_id : String) ; fn remove_in_edge_id (& mut self , edge_id : & str) ; fn add_out_edge_id (& mut self , edge_id : String) ; fn remove_out_edge_id (& mut self , edge_id : & str) ; }
pub trait Edge : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn id (& self) -> & str ; fn from_node_id (& self) -> & str ; fn to_node_id (& self) -> & str ; fn family_name (& self) -> String ; }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct SomeNodeType { id : String , in_edge_ids : Vec < String > , out_edge_ids : Vec < String > , data : String , other_data : String , } impl SomeNodeType { pub fn new (id : Option < String > , data : String , other_data : String ,) -> Self { Self { id : format ! (concat ! (stringify ! (SomeNodeType) , ":{}") , id . unwrap_or (xid :: new () . to_string ())) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , data , other_data , } } } impl std :: str :: FromStr for SomeNodeType { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for SomeNodeType { fn id (& self) -> & str { & self . id } fn in_edge_ids (& self) -> Vec < String > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : String) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : & str) { self . in_edge_ids . retain (| x | x != edge_id) ; } fn out_edge_ids (& self) -> Vec < String > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : String) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : & str) { self . out_edge_ids . retain (| x | x != edge_id) ; } fn family_name (& self) -> String { stringify ! (SomeNodeType) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct AnotherNodeType { id : String , in_edge_ids : Vec < String > , out_edge_ids : Vec < String > , data : String , tracked : bool , } impl AnotherNodeType { pub fn new (id : Option < String > , data : String , tracked : bool ,) -> Self { Self { id : format ! (concat ! (stringify ! (AnotherNodeType) , ":{}") , id . unwrap_or (xid :: new () . to_string ())) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , data , tracked , } } } impl std :: str :: FromStr for AnotherNodeType { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for AnotherNodeType { fn id (& self) -> & str { & self . id } fn in_edge_ids (& self) -> Vec < String > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : String) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : & str) { self . in_edge_ids . retain (| x | x != edge_id) ; } fn out_edge_ids (& self) -> Vec < String > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : String) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : & str) { self . out_edge_ids . retain (| x | x != edge_id) ; } fn family_name (& self) -> String { stringify ! (AnotherNodeType) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone)] pub struct SomeEdgeType { id : String , from_node_id : String , to_node_id : String , weight : f64 , } impl SomeEdgeType { pub fn new_between (id : Option < String > , from_node_id : & str , to_node_id : & str , weight : f64 ,) -> Self { Self { id : format ! (concat ! (stringify ! (SomeEdgeType) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ())) , from_node_id : from_node_id . to_string () , to_node_id : to_node_id . to_string () , weight } } } impl std :: str :: FromStr for SomeEdgeType { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Edge for SomeEdgeType { fn id (& self) -> & str { & self . id } fn from_node_id (& self) -> & str { & self . from_node_id } fn to_node_id (& self) -> & str { & self . to_node_id } fn family_name (& self) -> String { stringify ! (SomeEdgeType) . to_string () } }
pub fn families () -> Vec < & 'static str > { vec ! ["SomeNodeType" , "AnotherNodeType" , "SomeEdgeType"] }
