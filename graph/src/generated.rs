use serde :: { Serialize , Deserialize } ; use xid ;
pub trait NodeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn new (id : Option < String >) -> Self ; fn to_string (& self) -> String ; fn family_name (& self) -> String ; } pub trait NodeValidInEdgeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { } pub trait NodeValidOutEdgeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { } pub trait Node : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { type Id : NodeId ; type ValidInEdgeId : NodeValidInEdgeId ; type ValidOutEdgeId : NodeValidOutEdgeId ; fn id (& self) -> & Self :: Id ; fn in_edge_ids (& self) -> Vec < Self :: ValidInEdgeId > ; fn out_edge_ids (& self) -> Vec < Self :: ValidOutEdgeId > ; fn add_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) ; fn remove_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) ; fn add_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) ; fn remove_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) ; fn family_name (& self) -> String ; }
pub trait EdgeId : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { fn to_string (& self) -> String ; fn family_name (& self) -> String ; } pub trait EdgeConnection : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { } pub trait Edge : Serialize + for < 'de > Deserialize < 'de > + Clone + std :: fmt :: Debug { type Id : EdgeId ; type Connection : EdgeConnection ; fn id (& self) -> & Self :: Id ; fn connection (& self) -> & Self :: Connection ; fn family_name (& self) -> String ; }
# [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub struct ById (String) ; impl EdgeId for ById { fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (By) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone)] pub enum ByConnection { SongIsBy (SongId , ArtistId) , AlbumIsBy (AlbumId , ArtistId) } impl EdgeConnection for ByConnection { } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct By { id : ById , connection : ByConnection , weight : f64 , } impl By { pub fn new (id : Option < String > , connection : ByConnection , weight : f64 ,) -> Self { Self { id : ById (format ! (concat ! (stringify ! (By) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) , connection , weight } } pub fn id (& self) -> & ById { & self . id } } impl std :: str :: FromStr for By { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Edge for By { type Id = ById ; type Connection = ByConnection ; fn id (& self) -> & Self :: Id { & self . id } fn connection (& self) -> & Self :: Connection { & self . connection } fn family_name (& self) -> String { stringify ! (By) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub struct SongId (String) ; impl NodeId for SongId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (Song) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (Song) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub enum SongInEdge { } impl NodeValidInEdgeId for SongInEdge { } # [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub enum SongOutEdge { ById (ById) , } impl NodeValidOutEdgeId for SongOutEdge { } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct Song { id : SongId , in_edge_ids : Vec < SongInEdge > , out_edge_ids : Vec < SongOutEdge > , title : String , } impl Song { pub fn new (id : Option < String > , title : String ,) -> Self { Self { id : SongId (format ! (concat ! (stringify ! (Song) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , title , } } pub fn new_id (id : String) -> SongId { SongId (format ! (concat ! (stringify ! (Song) , ":{}") , id)) } } impl std :: str :: FromStr for Song { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for Song { type Id = SongId ; type ValidInEdgeId = SongInEdge ; type ValidOutEdgeId = SongOutEdge ; fn id (& self) -> & SongId { & self . id } fn in_edge_ids (& self) -> Vec < Self :: ValidInEdgeId > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) { self . in_edge_ids . retain (| x | x != & edge_id) ; } fn out_edge_ids (& self) -> Vec < Self :: ValidOutEdgeId > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) { self . out_edge_ids . retain (| x | x != & edge_id) ; } fn family_name (& self) -> String { stringify ! (Song) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub struct ArtistId (String) ; impl NodeId for ArtistId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (Artist) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (Artist) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub enum ArtistInEdge { ById (ById) , } impl NodeValidInEdgeId for ArtistInEdge { } # [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub enum ArtistOutEdge { } impl NodeValidOutEdgeId for ArtistOutEdge { } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct Artist { id : ArtistId , in_edge_ids : Vec < ArtistInEdge > , out_edge_ids : Vec < ArtistOutEdge > , name : String , } impl Artist { pub fn new (id : Option < String > , name : String ,) -> Self { Self { id : ArtistId (format ! (concat ! (stringify ! (Artist) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , name , } } pub fn new_id (id : String) -> ArtistId { ArtistId (format ! (concat ! (stringify ! (Artist) , ":{}") , id)) } } impl std :: str :: FromStr for Artist { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for Artist { type Id = ArtistId ; type ValidInEdgeId = ArtistInEdge ; type ValidOutEdgeId = ArtistOutEdge ; fn id (& self) -> & ArtistId { & self . id } fn in_edge_ids (& self) -> Vec < Self :: ValidInEdgeId > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) { self . in_edge_ids . retain (| x | x != & edge_id) ; } fn out_edge_ids (& self) -> Vec < Self :: ValidOutEdgeId > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) { self . out_edge_ids . retain (| x | x != & edge_id) ; } fn family_name (& self) -> String { stringify ! (Artist) . to_string () } }
# [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub struct AlbumId (String) ; impl NodeId for AlbumId { fn new (id : Option < String >) -> Self { Self (format ! (concat ! (stringify ! (Album) , ":{}") , id . unwrap_or_else (|| xid :: new () . to_string ()))) } fn to_string (& self) -> String { self . 0 . clone () } fn family_name (& self) -> String { stringify ! (Album) . to_string () } } # [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub enum AlbumInEdge { } impl NodeValidInEdgeId for AlbumInEdge { } # [derive (Debug , Serialize , Deserialize , Clone , PartialEq)] pub enum AlbumOutEdge { ById (ById) , } impl NodeValidOutEdgeId for AlbumOutEdge { } # [derive (Debug , Serialize , Deserialize , Clone)] pub struct Album { id : AlbumId , in_edge_ids : Vec < AlbumInEdge > , out_edge_ids : Vec < AlbumOutEdge > , title : String , } impl Album { pub fn new (id : Option < String > , title : String ,) -> Self { Self { id : AlbumId (format ! (concat ! (stringify ! (Album) , ":{}") , id . unwrap_or (xid :: new () . to_string ()))) , in_edge_ids : Vec :: new () , out_edge_ids : Vec :: new () , title , } } pub fn new_id (id : String) -> AlbumId { AlbumId (format ! (concat ! (stringify ! (Album) , ":{}") , id)) } } impl std :: str :: FromStr for Album { type Err = serde_json :: Error ; fn from_str (s : & str) -> Result < Self , Self :: Err > { serde_json :: from_str :: < Self > (s) } } impl Node for Album { type Id = AlbumId ; type ValidInEdgeId = AlbumInEdge ; type ValidOutEdgeId = AlbumOutEdge ; fn id (& self) -> & AlbumId { & self . id } fn in_edge_ids (& self) -> Vec < Self :: ValidInEdgeId > { self . in_edge_ids . clone () } fn add_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) { self . in_edge_ids . push (edge_id) ; } fn remove_in_edge_id (& mut self , edge_id : Self :: ValidInEdgeId) { self . in_edge_ids . retain (| x | x != & edge_id) ; } fn out_edge_ids (& self) -> Vec < Self :: ValidOutEdgeId > { self . out_edge_ids . clone () } fn add_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) { self . out_edge_ids . push (edge_id) ; } fn remove_out_edge_id (& mut self , edge_id : Self :: ValidOutEdgeId) { self . out_edge_ids . retain (| x | x != & edge_id) ; } fn family_name (& self) -> String { stringify ! (Album) . to_string () } }
pub fn families () -> Vec < & 'static str > { vec ! ["By"] }
